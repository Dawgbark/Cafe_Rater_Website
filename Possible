<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Cafe Scout – Standalone</title>
    <link
      rel="stylesheet"
      href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
      integrity="sha512-sA+e2Xv5lZ8tft1kYyqS/fWznuaCG2lKT9OAXoJ2i8LojRxurx8WcN6iYG3PaY5E9O+V1YQUiSO1kzWw5o7WlA=="
      crossorigin=""
    />
    <style>
      :root {
        color-scheme: light;
        --bg: #f7f6f0;
        --surface: #ffffff;
        --text: #1d1d1d;
        --muted: #666;
        --border: #e5e5e5;
        --accent: #2f6f4e;
        --accent-muted: #d7e7dd;
        --shadow: 0 6px 20px rgba(0, 0, 0, 0.08);
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
        background: var(--bg);
        color: var(--text);
      }

      header {
        padding: 1rem 1.5rem 0.5rem;
        display: flex;
        flex-wrap: wrap;
        align-items: baseline;
        gap: 0.75rem;
      }

      h1 {
        margin: 0;
        font-size: 1.4rem;
      }

      .lead {
        margin: 0;
        color: var(--muted);
        font-size: 0.95rem;
      }

      main {
        display: grid;
        grid-template-columns: 2fr 1fr;
        gap: 1.25rem;
        padding: 0 1.5rem 1.5rem;
      }

      #map {
        height: 70vh;
        min-height: 320px;
        border-radius: 12px;
        box-shadow: var(--shadow);
        overflow: hidden;
      }

      .sidebar {
        background: var(--surface);
        border-radius: 12px;
        box-shadow: var(--shadow);
        padding: 1rem;
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
        min-height: 70vh;
      }

      .controls {
        display: flex;
        flex-wrap: wrap;
        gap: 0.5rem;
      }

      input[type="text"] {
        flex: 1;
        min-width: 180px;
        padding: 0.6rem 0.75rem;
        border: 1px solid var(--border);
        border-radius: 10px;
      }

      select,
      button {
        padding: 0.6rem 0.75rem;
        border-radius: 10px;
        border: none;
        cursor: pointer;
        font-weight: 600;
      }

      button.primary {
        background: var(--accent);
        color: #fff;
      }

      button.secondary {
        background: #f0f0f0;
        color: #333;
      }

      button:disabled {
        opacity: 0.6;
        cursor: wait;
      }

      #status {
        font-size: 0.9rem;
        color: var(--muted);
        min-height: 1.2em;
      }

      #status.is-error {
        color: #b3261e;
      }

      .results-list {
        flex: 1;
        overflow-y: auto;
        margin: 0;
        padding: 0;
        list-style: none;
      }

      .result-item {
        padding: 0.75rem 0;
        border-bottom: 1px solid #f0f0f0;
      }

      .result-item:last-child {
        border-bottom: none;
      }

      .result-item h3 {
        margin: 0 0 0.3rem;
        font-size: 1rem;
      }

      .result-item .meta {
        color: var(--muted);
        font-size: 0.85rem;
        margin: 0.2rem 0 0;
      }

      .result-item button {
        margin-top: 0.35rem;
      }

      @media (max-width: 960px) {
        main {
          grid-template-columns: 1fr;
        }

        #map,
        .sidebar {
          min-height: 50vh;
        }
      }
    </style>
  </head>
  <body>
    <header>
      <h1>Cafe Scout</h1>
      <p class="lead">Discover nearby cafés anywhere you are. Powered by OpenStreetMap.</p>
    </header>
    <main>
      <div id="map"></div>
      <aside class="sidebar">
        <div class="controls">
          <button id="btn-locate" class="primary" type="button">Use my location</button>
          <input
            id="search-input"
            type="text"
            name="q"
            placeholder="Search a place…"
            autocomplete="off"
          />
          <button id="btn-search" class="secondary" type="button">Search</button>
          <select id="radius-select" aria-label="Search radius">
            <option value="1000">1 km</option>
            <option value="2000">2 km</option>
            <option value="3000" selected>3 km</option>
            <option value="5000">5 km</option>
            <option value="8000">8 km</option>
            <option value="10000">10 km</option>
          </select>
        </div>
        <div id="status"></div>
        <ul class="results-list" id="results"></ul>
      </aside>
    </main>

    <script
      src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
      integrity="sha512-vI7J3gFQ0pFB70dNDO7xjoMnIKPQ4j/wcgUp3NEiqPFcAckBW4iigFsMghvYDn8ApX2HFqcks8uuSS4o6Zh4qQ=="
      crossorigin=""
    ></script>
    <script>
      const DEFAULT_COORDS = { lat: 39.1031, lon: -84.512 }; // Cincinnati demo
      const TILE_LAYER_URL = "https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png";
      const TILE_LAYER_ATTRIBUTION = "© OpenStreetMap contributors";
      const EARTH_RADIUS_METERS = 6371000;
      const OVERPASS_URL = "https://overpass-api.de/api/interpreter";

      const map = L.map("map").setView([DEFAULT_COORDS.lat, DEFAULT_COORDS.lon], 13);
      L.tileLayer(TILE_LAYER_URL, {
        attribution: TILE_LAYER_ATTRIBUTION,
        maxZoom: 19,
      }).addTo(map);
      const markersLayer = L.layerGroup().addTo(map);

      const locateBtn = document.getElementById("btn-locate");
      const searchBtn = document.getElementById("btn-search");
      const searchInput = document.getElementById("search-input");
      const radiusSelect = document.getElementById("radius-select");
      const statusEl = document.getElementById("status");
      const resultsEl = document.getElementById("results");

      let currentLocation = null;
      let isInitialLoad = true;

      const lifecyclePrefixes = ["disused:", "abandoned:", "was:"];
      const lifecycleFlags = ["disused", "abandoned", "closed"];
      const closedPattern = /\bclosed\b/i;

      function setStatus(message, { isError = false } = {}) {
        statusEl.textContent = message || "";
        statusEl.classList.toggle("is-error", Boolean(isError));
      }

      function setLoading(button, isLoading, idleLabel) {
        if (!button) return;
        if (isLoading) {
          button.dataset.label = button.textContent;
          button.textContent = idleLabel || "Working…";
        } else if (button.dataset.label) {
          button.textContent = button.dataset.label;
          delete button.dataset.label;
        }
        button.disabled = isLoading;
      }

      function clearResults() {
        markersLayer.clearLayers();
        resultsEl.innerHTML = "";
      }

      function calculateDistanceMeters(lat1, lon1, lat2, lon2) {
        const toRad = (value) => (value * Math.PI) / 180;
        const dLat = toRad(lat2 - lat1);
        const dLon = toRad(lon2 - lon1);
        const originLat = toRad(lat1);
        const targetLat = toRad(lat2);

        const a =
          Math.sin(dLat / 2) * Math.sin(dLat / 2) +
          Math.sin(dLon / 2) * Math.sin(dLon / 2) * Math.cos(originLat) * Math.cos(targetLat);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        return EARTH_RADIUS_METERS * c;
      }

      function formatDistance(distanceMeters) {
        if (!Number.isFinite(distanceMeters)) return null;
        if (distanceMeters < 1000) {
          return `${Math.round(distanceMeters)} m away`;
        }
        const kilometers = distanceMeters / 1000;
        return `${kilometers.toFixed(kilometers < 10 ? 1 : 0)} km away`;
      }

      function focusCafeOnMap(cafe, marker) {
        const zoom = Math.max(map.getZoom(), 16);
        map.setView([cafe.lat, cafe.lon], zoom);
        if (marker) {
          marker.openPopup();
        }
      }

      function buildResultItem(cafe, distanceMeters, marker) {
        const item = document.createElement("li");
        item.className = "result-item";
        item.tabIndex = 0;

        const title = document.createElement("h3");
        title.textContent = cafe.name || "Unnamed Cafe";
        item.appendChild(title);

        if (cafe.address) {
          const address = document.createElement("p");
          address.className = "meta";
          address.textContent = cafe.address;
          item.appendChild(address);
        }

        const distanceLabel = formatDistance(distanceMeters);
        if (distanceLabel) {
          const distance = document.createElement("p");
          distance.className = "meta";
          distance.textContent = distanceLabel;
          item.appendChild(distance);
        }

        const focusButton = document.createElement("button");
        focusButton.type = "button";
        focusButton.className = "secondary";
        focusButton.textContent = "Show on map";
        focusButton.addEventListener("click", () => focusCafeOnMap(cafe, marker));
        item.appendChild(focusButton);

        return item;
      }

      function zoomForRadius(radius) {
        if (radius <= 1000) return 15;
        if (radius <= 2000) return 14;
        if (radius <= 4000) return 13;
        if (radius <= 8000) return 12;
        return 11;
      }

      function buildOverpassQuery(lat, lon, radius) {
        return `
      [out:json][timeout:60];
      (
        node["amenity"="cafe"](around:${radius},${lat},${lon});
        way["amenity"="cafe"](around:${radius},${lat},${lon});
        relation["amenity"="cafe"](around:${radius},${lat},${lon});
        node["amenity"="coffee_shop"](around:${radius},${lat},${lon});
        way["amenity"="coffee_shop"](around:${radius},${lat},${lon});
        relation["amenity"="coffee_shop"](around:${radius},${lat},${lon});
      );
      ["disused:amenity" !~ "."]
      ["abandoned:amenity" !~ "."]
      ["was:amenity" !~ "."]
      ["end_date" !~ "."]
      ["disused" != "yes"]
      ["abandoned" != "yes"]
      ["closed" != "yes"]
      ["name" !~ "(?i)closed"]
      -> .results;
      (.results;);
      out center tags;`.trim();
      }

      function isOpenCafe(tags) {
        if (!tags) return true;
        for (const key of Object.keys(tags)) {
          const lower = key.toLowerCase();
          if (lifecyclePrefixes.some((prefix) => lower.startsWith(prefix))) {
            return false;
          }
        }
        if (lifecycleFlags.some((flag) => tags[flag] === "yes")) return false;
        if (tags["end_date"]) return false;
        const name = tags["name"] || tags["brand"] || "";
        if (closedPattern.test(name)) return false;
        return true;
      }

      function formatAddress(tags) {
        const parts = [
          tags["addr:housenumber"],
          tags["addr:street"],
          tags["addr:city"],
          tags["addr:postcode"],
        ].filter(Boolean);
        return parts.length ? parts.join(", ") : null;
      }

      function parseOverpassElements(elements) {
        const cafes = [];
        const seen = new Set();
        for (const element of elements || []) {
          const tags = element.tags || {};
          if (!isOpenCafe(tags)) continue;

          const osmId = element.id;
          const osmType = element.type;
          if (osmId && osmType) {
            const key = `${osmType}:${osmId}`;
            if (seen.has(key)) continue;
            seen.add(key);
          }

          let { lat, lon } = element;
          if (lat == null || lon == null) {
            const center = element.center || {};
            lat = center.lat;
            lon = center.lon;
          }
          if (lat == null || lon == null) continue;

          cafes.push({
            name: tags.name || tags.brand || "Unnamed Cafe",
            lat,
            lon,
            address: formatAddress(tags),
          });
        }
        return cafes;
      }

      async function fetchCafes(lat, lon, radius) {
        const query = buildOverpassQuery(lat, lon, radius);
        const body = new URLSearchParams({ data: query });
        const response = await fetch(OVERPASS_URL, {
          method: "POST",
          body,
          headers: { Accept: "application/json" },
        });
        if (!response.ok) {
          throw new Error("Cafe API request failed");
        }
        const payload = await response.json();
        return Array.isArray(payload.elements) ? parseOverpassElements(payload.elements) : [];
      }

      function renderCafes(cafes) {
        clearResults();

        if (!cafes.length) {
          setStatus("No cafés found nearby. Try widening the search radius.", { isError: true });
          const emptyItem = document.createElement("li");
          emptyItem.className = "result-item";
          const message = document.createElement("p");
          message.className = "meta";
          message.textContent = "No cafés found.";
          emptyItem.appendChild(message);
          resultsEl.appendChild(emptyItem);
          return;
        }

        setStatus(`Found ${cafes.length} café${cafes.length === 1 ? "" : "s"}.`);

        const origin = currentLocation;
        cafes.forEach((cafe) => {
          const marker = L.marker([cafe.lat, cafe.lon]).addTo(markersLayer);
          marker.bindPopup(
            `<strong>${cafe.name || "Cafe"}</strong>${cafe.address ? `<br>${cafe.address}` : ""}`
          );

          const distance = origin
            ? calculateDistanceMeters(origin.lat, origin.lon, cafe.lat, cafe.lon)
            : null;

          resultsEl.appendChild(buildResultItem(cafe, distance, marker));
        });
      }

      async function loadCafes(lat, lon, radius, { recenter = true } = {}) {
        setStatus("Searching for cafés…");
        try {
          currentLocation = { lat, lon };
          const cafes = await fetchCafes(lat, lon, radius);
          if (recenter) {
            map.setView([lat, lon], zoomForRadius(radius));
          }
          renderCafes(cafes);
        } catch (error) {
          console.error(error);
          setStatus("Unable to load cafés. Please try again.", { isError: true });
        }
      }

      async function geocodePlace(query) {
        const url = new URL("https://nominatim.openstreetmap.org/search");
        url.searchParams.set("q", query);
        url.searchParams.set("format", "jsonv2");
        url.searchParams.set("limit", "1");

        const response = await fetch(url.toString(), {
          headers: {
            "Accept-Language": "en",
          },
        });
        if (!response.ok) {
          throw new Error("Geocoding request failed");
        }
        const data = await response.json();
        if (!Array.isArray(data) || !data.length) {
          return null;
        }
        const match = data[0];
        return {
          lat: parseFloat(match.lat),
          lon: parseFloat(match.lon),
          displayName: match.display_name,
        };
      }

      async function handleSearch() {
        const query = searchInput.value.trim();
        if (!query) {
          setStatus("Type a city, neighborhood, or landmark to search.", { isError: true });
          return;
        }

        setLoading(searchBtn, true, "Searching…");
        setStatus("Locating place…");

        try {
          const location = await geocodePlace(`${query} cafe`);
          if (!location) {
            setStatus("Place not found. Try a different search.", { isError: true });
            return;
          }

          const radius = parseInt(radiusSelect.value, 10) || 3000;
          await loadCafes(location.lat, location.lon, radius, { recenter: true });
        } catch (error) {
          console.error(error);
          setStatus("Search failed. Please try again.", { isError: true });
        } finally {
          setLoading(searchBtn, false);
        }
      }

      function handleLocationSuccess(position) {
        const { latitude, longitude } = position.coords;
        const radius = parseInt(radiusSelect.value, 10) || 3000;
        loadCafes(latitude, longitude, radius, { recenter: true });
      }

      function handleLocationError(error) {
        console.error(error);
        if (isInitialLoad) {
          setStatus("Location blocked. Showing cafes near the default view.", { isError: true });
          const radius = parseInt(radiusSelect.value, 10) || 3000;
          loadCafes(DEFAULT_COORDS.lat, DEFAULT_COORDS.lon, radius, { recenter: true });
        } else {
          setStatus(error.message || "Unable to access your location.", { isError: true });
        }
      }

      function requestUserLocation() {
        if (!navigator.geolocation) {
          setStatus("Geolocation isn't supported by your browser.", { isError: true });
          return;
        }

        setLoading(locateBtn, true, "Locating…");
        setStatus("Finding your location…");

        navigator.geolocation.getCurrentPosition(
          (position) => {
            setLoading(locateBtn, false);
            handleLocationSuccess(position);
          },
          (error) => {
            setLoading(locateBtn, false);
            handleLocationError(error);
          },
          {
            enableHighAccuracy: false,
            timeout: 15000,
            maximumAge: 60000,
          }
        );
      }

      radiusSelect.addEventListener("change", () => {
        if (!currentLocation) {
          return;
        }
        const radius = parseInt(radiusSelect.value, 10) || 3000;
        loadCafes(currentLocation.lat, currentLocation.lon, radius, { recenter: false });
      });

      locateBtn.addEventListener("click", () => {
        isInitialLoad = false;
        requestUserLocation();
      });

      searchBtn.addEventListener("click", () => {
        isInitialLoad = false;
        handleSearch();
      });

      searchInput.addEventListener("keydown", (event) => {
        if (event.key === "Enter") {
          event.preventDefault();
          isInitialLoad = false;
          handleSearch();
        }
      });

      (async function init() {
        try {
          requestUserLocation();
        } finally {
          isInitialLoad = false;
        }
      })();
    </script>
  </body>
</html>
